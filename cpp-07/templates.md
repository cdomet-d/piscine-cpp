# Templates in C++98

Templates in C++98 (and subsequent versions) are snippets of codes that enables generic programming, meaning that you can do a lot with just one "model" function.

You can make make:

- function templates,
- class templates,
- member functions templates.

Some templates can be specialized with multiple arguments or default arguments.

The syntax is as follows:

# Template syntax

## Function Templates

```cpp
	template <typename T>

	// T stands for a given datatype (int, double...)

	T max(T x, T y) {
		return (x > y) ? x : y;
	}
```

`max(x, y)` can now be used for any datatype that will support the operation made by the function, provided that you specify a type when using:

```cpp
	int res = max<int>(10, 8);
```

## Class Templates

Class templates allow the user to create a class that can work with different datatypes. A prime example of this is `std::vector`, that can be with any datatypes:

```cpp
	template <class T>

	class vector
	{
		public:
			void push_back(const T& x);
			T& at(size_t index);

		private:
			T* array;
			size_t size;
			// etc...
	}
```

Once that's done, one can initialize any type of vector:

```cpp
	vector<int> iVec;
	vector<double> dVec;
	vector<std::string> sVec;
	vector<vector<std::string>> 2dSVec;
	// etc...
```

## Multiple arguments Templates

It is possible to declate templates with multiple arguments, be it class templates or function templates. The syntax is as follows :

```cpp
	template <class T, class U>

	class A
	{
	public:
		A()
		~A()
	private:
		T x;
		U y;
};
```

## Default arguments

When creating a template for which a case is most common, it's possible to declare a default argument:

```cpp
	template <typename T = int>

	// T stands for a given datatype (int, double...)

	T max(T x, T y) {
		return (x > y) ? x : y;
	}
```

That way, passing arguments to the functions will be by default treated as intergers, while still allowing the user to specify another type should the need arise.

# Instantiated function template

_see also template specialization_

ressource: [LearnCpp](https://www.learncpp.com/cpp-tutorial/function-template-instantiation/)

An instanciated function template is a function that has been generated by a function template.

Basically, when you call your template function, the compiler converts the template with the types you gave the function and it becomes a concrete function. This works just the same as any function you would use normally.

```cpp
	template <typename T>

	T max(T x, T y) {
		return (x > y) ? x : y;
	}

	int main()
	{
		int a = 15;
		int b = 5;

		std::cout << "Testing max(T a, T b) with int values"
				  << std::endl
				  << "The greater of " << a << " and " << b << " is	" << max(a, b) << std::endl
				  << std::endl;
	}
```
Key takeways: 
- 
- The compiler replaces the placeholder datatypes with those provided at compile time. The conversion from template to specialized function is automatic and occurs when the compiler encounters a template call. 
- One the template is instanciated, the same function is used for all calls with the same type. in that translation unit ([basically each of your .cpp files after they have been processed by the preprocessor, but before it was linked, though it's a bit more complicated than that.](https://dengking.github.io/programming-language/Theory/Organization/Translation-unit/)). Basically, if you call the same template five times in the same file, it will only be instanciated once. 